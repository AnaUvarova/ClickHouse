---
title: Why ClickHouse is so fast?
toc_hidden: true
toc_priority: 8
---

#  Почему ClickHouse так быстро работает? {#why-clickhouse-is-so-fast}

Изначально он был разработан так, чтобы быть быстрым. Производительность выполнения запросов всегда была самой важной в процессе разработки, но и другие важные характеристики, как например, комфорт пользователя, масштабируемость и защищенность также принимались во внимание, так чтобы ClickHouse стал системой с серьезной производительностью. 

Сначала ClickHouse был построен как прототип для выполнения одной вещи на отлично: фильтровать и агрегировать данные так быстро, насколько это возможно. Это именно то, что необходимо, чтобы создать типичный аналитический ответ и то, что происходит по стандартном запросу [GROUP BY](../../sql-reference/statements/select/group-by.md). Команда ClickHouse приняла несколько высокоуровневых решения, которые все вместе сделали достижимой следующую цель: 

Колоночое хранилище
:   Исходные данные часто содержат сотни или даже тысячи столбцов, в то время как для отчета нужно только несколько из них. Система не должна читать ненужные столбцы, иначе самые дорогостоящие операции прочтения с диска будут производиться зря. 

Индексы
:   ClickHouse хранит в памяти структуры данных, а это позволяет читать не только используемые столбцы, но только необходимые диапазоны строк для этих столбцов.

Сжатие данных
:   Хранение различных значений одной и той же колонки вместе часто ведет к лучшим пропорциям сжатия (по сравнению со стандартными ориентированными на строки системами). Причина тому — в реальности столбец данных часто имеет такие же или не слишком различные значения для соседних строк. А в дополнение к универсальному сжатию ClickHouse поддерживает [специализированные кодеки](../../sql-reference/statements/create/table.md#create-query-specialized-codecs), которые могут ужать данные еще больше. 

Выполнение векторизованного запроса
:   ClickHouse не только хранит данные в столбцах, но также обрабатывает их. А это приводит к улучшению использования кеша процессора и позволяет использовать инструкции [SIMD](https://en.wikipedia.org/wiki/SIMD).

Масштабируемость
:   ClickHouse может использовать все доступные ядра процессоров, а также диски, чтобы выполнить даже одиночный запрос. Не только на отдельном сервере, но на всех процессорных ядрах и дисках целого кластера.

Похожие техники используют и многие другие СУБД. **Внимание к низкоуровневым деталям** — вот, что делает ClickHouse по-настоящему особенным. Большинство языков программирования предоставляют реализации для большинства распространенных алгоритмов и структур данных, но в целом они слишком общие (поверхностные), чтобы быть эффективными. Каждую задачу можно рассмотреть как пейзах с различными характеристиками вместо того, чтобы просто взять случайную реализацию. К примеру, если вам нужна таблица хешей, вот несколько ключевых вопросов к размышлению:

-   Какую функцию следует выбрать?
-   Алгоритм разрешения противоречий: [открытая адресация](https://en.wikipedia.org/wiki/Open_addressing) против [связывания](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining)?
-   Схема памяти: один массив для ключей и значений или отдельные массивы? Будут ли хранится маленькие или большие значения?
-   Фактор заполнения: когда и как менять размер? Как перемещать значения при изменении размера?
-   Будут ли значения перемещаться и какой алгоритм сработает лучше при этом?
-   Понадобится ли нам Will we need быстрое зондирование с растровыми изображениями, вхождение строчных ключей, поддержка неперемещаемых значений, предварительная выборка и пакетирование?

Хеш-таблица — ключевая структура данных для реализации `GROUP BY` и ClickHouse автоматически выбирает одну из [более, чем 30-ти вариаций](https://github.com/ClickHouse/ClickHouse/blob/master/src/Interpreters/Aggregator.h) для каждого специфического запроса.

Аналогично происходит для алгоритмов, например, при сортировки вы могли бы подумать о:

-   Что будет сортироваться: массив чисел, кортежи, строки или структуры?
-   Все ли данные полностью доступны в RAM?
-   Нужна ли стабильная сортировка?
-   Нужна ли нам полная сортировка? Будет ли достаточно частичной сортировки некоторого количества элементов?
-   Как реализовать сравнения?
-   Сортируем ли мы данные, которые уже частично сортировали?

Алгоритмы, которые основываются на характеристиках данных, с которыми они работают, справляются лучше, чем их более общие аналоги. Если заранее неизвестно, система может попробовать различные реализации и выбрать ту, которая лучше всего показала себя во время выполнения. К примеру, загляните в [статью о том, как распаковка LZ4 реализуется в ClickHouse](https://habr.com/en/company/yandex/blog/457612/). 

Ну и самое последнее, но тем не менее важное: команда ClickHouse всегда мониторит сообщения пользователей в Интернете о том, что еще стоит попробовать, тчобы улучшить имплементацию, алгоритм, или структуру данных. Иногда в этом потоке можно найти очень ценные идеи.

!!! info "Советы о том, как создать собственное высокопроизводительное ПО"


    -   Помните о низкоуровневых деталях уже на этапе проектирования системы.
    -   Учитывайте возможности аппаратного обеспечения.
    -   Выбирайте структуры данных и абстракции по требованиям задачи.
    -   Для особых случаев разрабатывайте специализированные решения.
    -   Пробуйте новые алгоритмы, которые будут лучше. Современные — о которых еще вчера вы только слышали.
    -   Выбирайте алгоритм по статистике во время работы.
    -   Ориентируйтесь на реальные датасеты.
    -   Проводите тестирование на снижение производительности в CI.
    -   Измеряйте и наблюдайте все, что только возможно.
